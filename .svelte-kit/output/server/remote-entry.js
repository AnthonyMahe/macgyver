import{get_request_store as e,with_request_store as t}from"@sveltejs/kit/internal/server";import{parse as r}from"devalue";import{error as n,json as s}from"@sveltejs/kit";import{d as o,s as i,B as a,c}from"./chunks/shared.js";import{b as u,c as l,p as f}from"./chunks/environment.js";function d(t,r){if(!r)return e=>{void 0!==e&&n(400,"Bad Request")};if("unchecked"===t)return e=>e;if("~standard"in t)return async r=>{const{event:s,state:o}=e(),i=t["~standard"].validate,a=await i(r);return a.issues&&n(400,await o.handleValidationError({issues:a.issues,event:s})),a.value};throw new Error('Invalid validator passed to remote function. Expected "unchecked" or a Standard Schema (https://standardschema.dev)')}async function p(e,t,r,n){await 0;const s=h(e,r);return s[o(t,r.transport)]??=n()}async function m(e,r,n,s,o,i){const a={event:{...e,setHeaders:()=>{throw new Error("setHeaders is not allowed in remote functions")},cookies:{...e.cookies,set:(t,r,s)=>{if(!n)throw new Error("Cannot set cookies in `query` or `prerender` functions");if(s.path&&!s.path.startsWith("/"))throw new Error("Cookies set in remote functions must have an absolute path");return e.cookies.set(t,r,s)},delete:(t,r)=>{if(!n)throw new Error("Cannot delete cookies in `query` or `prerender` functions");if(r.path&&!r.path.startsWith("/"))throw new Error("Cookies deleted in remote functions must have an absolute path");return e.cookies.delete(t,r)}}},state:{...r,is_in_remote_function:!0}},c=await t(a,()=>o(s));return t(a,()=>i(c))}function h(t,r=e().state){let n=r.remote_data?.get(t);return void 0===n&&(n={},(r.remote_data??=new Map).set(t,n)),n}function y(t,r){const n=r??t,s=d(t,r),o={type:"command",id:"",name:""},i=t=>{const{event:i,state:a}=e();if(a.is_endpoint_request){if(!["POST","PUT","PATCH","DELETE"].includes(i.request.method))throw new Error(`Cannot call a command (\`${o.name}(${r?"...":""})\`) from a ${i.request.method} handler`)}else if(!i.isRemoteRequest)throw new Error(`Cannot call a command (\`${o.name}(${r?"...":""})\`) during server-side rendering`);a.refreshes??={};const c=Promise.resolve(m(i,a,!0,t,s,n));return c.updates=()=>{throw new Error(`Cannot call '${o.name}(...).updates(...)' on the server`)},c};return Object.defineProperty(i,"__",{value:o}),Object.defineProperty(i,"pending",{get:()=>0}),i}function v(e,t,r){t.startsWith("n:")?(t=t.slice(2),r=""===r?void 0:parseFloat(r)):t.startsWith("b:")&&(t=t.slice(2),r="on"===r),b(e,function(e){if(!g.test(e))throw new Error(`Invalid path ${e}`);return e.split(/\.|\[|\]/).filter(Boolean)}(t),r)}const g=/^[a-zA-Z_$]\w*(\.[a-zA-Z_$]\w*|\[\d+\])*$/;function w(e){if("__proto__"===e||"constructor"===e||"prototype"===e)throw new Error(`Invalid key "${e}"`)}function b(e,t,r){let n=e;for(let o=0;o<t.length-1;o+=1){const e=t[o];w(e);const r=/^\d+$/.test(t[o+1]),s=e in n,i=n[e];if(s&&r!==Array.isArray(i))throw new Error(`Invalid array key ${t[o+1]}`);s||(n[e]=r?[]:{}),n=n[e]}const s=t[t.length-1];w(s),n[s]=r}function $(e,t,r,n,s=[]){const o=()=>function(e,t){let r=e;for(const n of t){if(null==r||"object"!=typeof r)return r;r=r[n]}return r}(t(),s);return new Proxy(e,{get(e,i){if("symbol"==typeof i)return e[i];if(/^\d+$/.test(i))return $({},t,r,n,[...s,parseInt(i,10)]);const a=function(e){let t="";for(const r of e)t+="number"==typeof r?`[${r}]`:""===t?r:"."+r;return t}(s);return"set"===i?$(function(e){return r(s,e),e},t,r,n,[...s,i]):"value"===i?$(o,t,r,n,[...s,i]):"issues"===i||"allIssues"===i?$(()=>{const e=n()[""===a?"$":a];return"allIssues"===i?e?.map(e=>({message:e.message})):e?.filter(e=>e.name===a)?.map(e=>({message:e.message}))},t,r,n,[...s,i]):"as"===i?$((e,t)=>{const r="file multiple"===e||"select multiple"===e||"checkbox"===e&&"string"==typeof t,s={name:("number"===e||"range"===e?"n:":"checkbox"!==e||r?"":"b:")+a+(r?"[]":""),get"aria-invalid"(){const e=n();return a in e?"true":void 0}};return"text"!==e&&"select"!==e&&"select multiple"!==e&&(s.type="file multiple"===e?"file":e),"submit"===e||"hidden"===e?Object.defineProperties(s,{value:{value:t,enumerable:!0}}):"select"===e||"select multiple"===e?Object.defineProperties(s,{multiple:{value:r,enumerable:!0},value:{enumerable:!0,get:()=>o()}}):"checkbox"===e||"radio"===e?Object.defineProperties(s,{value:{value:t??"on",enumerable:!0},checked:{enumerable:!0,get(){const n=o();return"radio"===e?n===t:r?(n??[]).includes(t):n}}}):"file"===e||"file multiple"===e?Object.defineProperties(s,{multiple:{value:r,enumerable:!0},files:{enumerable:!0,get(){const e=o();if(e instanceof File){if("undefined"!=typeof DataTransfer){const t=new DataTransfer;return t.items.add(e),t.files}return{0:e,length:1}}if(Array.isArray(e)&&e.every(e=>e instanceof File)){if("undefined"!=typeof DataTransfer){const t=new DataTransfer;return e.forEach(e=>t.items.add(e)),t.files}const t={length:e.length};return e.forEach((e,r)=>{t[r]=e}),t}return null}}}):Object.defineProperties(s,{value:{enumerable:!0,get(){const e=o();return null!=e?String(e):""}}})},t,r,n,[...s,"as"]):$({},t,r,n,[...s,i])}})}function P(t,r){const n=r??t,s=r&&"unchecked"!==t?t:null;return function t(o){const i={method:"POST"};Object.defineProperty(i,"enhance",{value:()=>({action:i.action,method:i.method})});const a={type:"submit",onclick:()=>{}};Object.defineProperty(a,"enhance",{value:()=>({type:"submit",formaction:i.buttonProps.formaction,onclick:()=>{}})}),Object.defineProperty(i,"buttonProps",{value:a});const c={type:"form",name:"",id:"",fn:async t=>{const o="true"===t.get("sveltekit:validate_only");let i=r?function(e){const t={};for(let r of e.keys()){if(r.startsWith("sveltekit:"))continue;const n=r.endsWith("[]");let s=e.getAll(r);if(n&&(r=r.slice(0,-2)),s.length>1&&!n)throw new Error(`Form cannot contain duplicated keys â€” "${r}" has ${s.length} values`);s=s.filter(e=>"string"==typeof e||""!==e.name||e.size>0),r.startsWith("n:")?(r=r.slice(2),s=s.map(e=>""===e?void 0:parseFloat(e))):r.startsWith("b:")&&(r=r.slice(2),s=s.map(e=>"on"===e)),v(t,r,n?s:s[0])}return t}(t):void 0;if(i&&void 0===i.id){const e=t.get("sveltekit:id");"string"==typeof e&&(i.id=JSON.parse(e))}const a={submission:!0},{event:u,state:l}=e(),f=await(s?.["~standard"].validate(i));if(o)return f?.issues??[];if(void 0!==f?.issues)_(a,f.issues,u.isRemoteRequest,t);else{void 0!==f&&(i=f.value),l.refreshes??={};const e=new Proxy(function(...e){throw new j(e.map(e=>"string"==typeof e?{path:[],message:e}:e))},{get:(e,t)=>"symbol"==typeof t?e[t]:O(t,(e,t=[])=>({message:e,path:t}),[])});try{a.result=await m(u,l,!0,i,e=>e,t=>r?n(t,e):n(e))}catch(d){if(!(d instanceof j))throw d;_(a,d.issues,u.isRemoteRequest,t)}}return u.isRemoteRequest||(h(c,l)[""]??=a),a}};return Object.defineProperty(i,"__",{value:c}),Object.defineProperty(i,"action",{get:()=>`?/remote=${c.id}`,enumerable:!0}),Object.defineProperty(a,"formaction",{get:()=>`?/remote=${c.id}`,enumerable:!0}),Object.defineProperty(i,"fields",{get(){const e=h(c)?.[""],t=function(e){const t={};for(const r of e){(t.$??=[]).push(r);let e="";if(void 0!==r.path)for(const n of r.path)"number"==typeof n?e+=`[${n}]`:"string"==typeof n&&(e+=""===e?n:"."+n),(t[e]??=[]).push(r)}return t}(e?.issues??[]);return $({},()=>e?.input??{},(t,r)=>{if(e?.submission)return;const n=0===t.length?r:b(e?.input??{},t.map(String),r);(h(c)[""]??={}).input=n},()=>t)}}),Object.defineProperty(i,"result",{get(){try{return h(c)?.[""]?.result}catch{return}}}),Object.defineProperty(i,"pending",{get:()=>0}),Object.defineProperty(a,"pending",{get:()=>0}),Object.defineProperty(i,"preflight",{value:()=>i}),Object.defineProperty(i,"validate",{value:()=>{throw new Error("Cannot call validate() on the server")}}),null==o&&Object.defineProperty(i,"for",{value:r=>{const{state:n}=e(),s=c.id+"|"+JSON.stringify(r);let o=(n.form_instances??=new Map).get(s);return o||(o=t(r),o.__.id=`${c.id}/${encodeURIComponent(JSON.stringify(r))}`,o.__.name=c.name,n.form_instances.set(s,o)),o}}),i}()}function _(e,t,r,n){if(e.issues=t.map(e=>function(e,t=!1){const r={name:"",path:[],message:e.message,server:t};if(void 0!==e.path){let t="";for(const n of e.path){const e="object"==typeof n?n.key:n;r.path.push(e),"number"==typeof e?t+=`[${e}]`:"string"==typeof e&&(t+=""===t?e:"."+e)}r.name=t}return r}(e,!0)),!r){e.input={};for(let t of n.keys()){if(/^[.\]]?_/.test(t))continue;const r=t.endsWith("[]"),s=n.getAll(t).filter(e=>"string"==typeof e);r&&(t=t.slice(0,-2)),v(e.input,t,r?s:s[0])}}}class j extends Error{constructor(e){super("Validation failed"),this.name="ValidationError",this.issues=e}}function O(e,t,r){const n=[...r,e];return new Proxy(e=>t(e,n),{get:(e,r)=>"symbol"==typeof r?e[r]:/^\d+$/.test(r)?O(parseInt(r,10),t,n):O(r,t,n)})}function k(t,c,f){const y="function"==typeof c?c:void 0,v=f??(y?void 0:c),g=y??t,w=d(t,y),b={type:"prerender",id:"",name:"",has_arg:!!y,inputs:v?.inputs,dynamic:v?.dynamic},$=t=>{const c=(async()=>{const{event:c,state:f}=e(),d=o(t,f.transport),y=`${u}/${l}/remote/${b.id}${d?`/${d}`:""}`;if(!f.prerendering&&!a&&!c.isRemoteRequest)try{return await p(b,t,f,async()=>{const e=o(t,f.transport),s=h(b,f),i=s[e]??=fetch(new URL(y,c.url.origin).href).then(async e=>{if(!e.ok)throw new Error("Prerendered response not found");const t=await e.json();return"error"===t.type&&n(t.status,t.error),t.result});return function(e,t){const n={};for(const r in t)n[r]=t[r].decode;return r(e,n)}(await i,f.transport)})}catch{}if(f.prerendering?.remote_responses.has(y))return f.prerendering.remote_responses.get(y);const v=p(b,t,f,()=>m(c,f,!1,t,w,g));f.prerendering&&f.prerendering.remote_responses.set(y,v);const $=await v;if(f.prerendering){const e={type:"result",result:i($,f.transport)};f.prerendering.dependencies.set(y,{body:JSON.stringify(e),response:s(e)})}return $})();return c.catch(()=>{}),c};return Object.defineProperty($,"__",{value:b}),$}function E(t,r){const n=r??t,s=d(t,r),i={type:"query",id:"",name:""},a=t=>{if(f)throw new Error(`Cannot call query '${i.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:r,state:a}=e(),u=p(i,t,a,()=>m(r,a,!1,t,s,n));return u.catch(()=>{}),u.set=r=>{const{state:n}=e(),s=n.refreshes;if(!s)throw new Error(`Cannot call set on query '${i.name}' because it is not executed in the context of a command/form remote function`);if(i.id){const e=h(i,n),a=o(t,n.transport);s[c(i.id,a)]=e[a]=Promise.resolve(r)}},u.refresh=()=>{const{state:r}=e(),n=r.refreshes;if(!n)throw new Error(`Cannot call refresh on query '${i.name}' because it is not executed in the context of a command/form remote function`);return n[c(i.id,o(t,r.transport))]=u,u.then(()=>{})},u.withOverride=()=>{throw new Error(`Cannot call '${i.name}.withOverride()' on the server`)},u};return Object.defineProperty(a,"__",{value:i}),a}Object.defineProperty(E,"batch",{value:function(t,r){const n=r??t,s=d(t,r),i={type:"query_batch",id:"",name:"",run:t=>{const{event:r,state:o}=e();return m(r,o,!1,t,e=>Promise.all(e.map(s)),n)}};let a={args:[],resolvers:[]};const u=t=>{if(f)throw new Error(`Cannot call query.batch '${i.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:r,state:u}=e(),l=p(i,t,u,()=>new Promise((e,o)=>{a.args.push(t),a.resolvers.push({resolve:e,reject:o}),a.args.length>1||setTimeout(async()=>{const e=a;a={args:[],resolvers:[]};try{const o=await m(r,u,!1,e.args,e=>Promise.all(e.map(s)),n);for(let r=0;r<e.resolvers.length;r++)try{e.resolvers[r].resolve(o(e.args[r],r))}catch(t){e.resolvers[r].reject(t)}}catch(t){for(const r of e.resolvers)r.reject(t)}},0)}));return l.catch(()=>{}),l.refresh=async()=>{const{state:r}=e(),n=r.refreshes;if(!n)throw new Error(`Cannot call refresh on query.batch '${i.name}' because it is not executed in the context of a command/form remote function`);n[c(i.id,o(t,r.transport))]=await l},l.withOverride=()=>{throw new Error(`Cannot call '${i.name}.withOverride()' on the server`)},l};return Object.defineProperty(u,"__",{value:i}),u},enumerable:!0});export{y as command,P as form,k as prerender,E as query};
